package fr.ensma.lias.rql;

import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

import fr.ensma.lias.rql.baseresults.BaseLine;
import fr.ensma.lias.rql.cfg.RqlCoreConf;
import fr.ensma.lias.rql.database.Database;
import fr.ensma.lias.rql.database.MysqlDB;
import fr.ensma.lias.rql.database.OracleDB;
import fr.ensma.lias.rql.database.PostgresqlDB;
import fr.ensma.lias.rql.dfg.Dfg;
import fr.ensma.lias.rql.rqlgrammar.RQLParser;
import fr.ensma.lias.rql.rulesgrammar.ParseException;
import fr.ensma.lias.rql.rulesgrammar.RulesParser;

/**
 * @author Gouriou Benjamin
 * @author Bilal REZKELLAH
 */
public class RQLManager implements Closeable {

	private String agFile = null;

	private PrintStream output = null;

	private OutputStream outStream = null;

	private Database db = null;

	private long startTime;

	private String shdPath;

	private RqlCoreConf rqlCoreConf = new RqlCoreConf();

	public RQLManager(String AgFile) {
		this.agFile = AgFile;
	}

	public RQLManager(RqlCoreConf cfgConf) {
		this.rqlCoreConf = cfgConf;
		this.shdPath = cfgConf.getPathToShd();
		agFile = cfgConf.getTmpAgFile();
		startTime = System.currentTimeMillis();
	}

	/**
	 * Initializes an RQL context without log output.
	 * 
	 * @param tmpAgFile the URL of the temporary file to store the agree set
	 */
	public RQLManager(String tmpAgFile, String shdPath) {
		if (tmpAgFile == null) {
			throw new NullPointerException("Temporary file can not be null.");
		}
		this.shdPath = shdPath;
		agFile = tmpAgFile;
		startTime = System.currentTimeMillis();
	}

	/**
	 * Initializes an RQL context.
	 * 
	 * @param tmpAgFile the URL of the temporary file to store the agree set
	 * @param log       the output stream, or null to disable
	 */
	public RQLManager(String tmpAgFile, String shdPath, PrintStream log) {
		this(tmpAgFile, shdPath);
		output = log;
	}

	/**
	 * Initializes an RQL context.
	 * 
	 * @param tmpAgFile the URL of the temporary file to store the agree set
	 * @param log       the URL of the output file, or null to disable
	 * 
	 * @throws IOException IO-related error
	 */
	public RQLManager(String tmpAgFile, String shdPath, String log) throws IOException {
		this(tmpAgFile, shdPath);
		if (log != null) {
			output = new PrintStream(log);
		}
	}

	/**
	 * Executes an RQL query.
	 * 
	 * @param rqlQuery    an RQL query
	 * @param outFilename the URL of the output file for rules
	 * 
	 * @throws SQLException                SQL-related error
	 * @throws IOException                 IO-related error
	 * @throws InterruptedException        Interruption during the execution of DFG
	 * @throws rulesgrammar.ParseException Wrong syntax in rules generated by DFG
	 * @throws rqlgrammar.ParseException   Wrong syntax in the RQL query
	 */
	public List<String> executeQuery(String rqlQuery, String outFilename)
			throws SQLException, IOException, InterruptedException, fr.ensma.lias.rql.rulesgrammar.ParseException,
			fr.ensma.lias.rql.rqlgrammar.ParseException {

		log("RQL query:\n" + rqlQuery);
		log("parsing RQL query");
		RQLParser parser = RQLParser.parse(rqlQuery);
		System.out.println(rqlQuery);
		log("generating SQL query");

		String sqlQuery = "";
		if (rqlCoreConf.getRqlDbType().equals("oracle")) {
			sqlQuery = parser.oracleQuery();
		} else if (rqlCoreConf.getRqlDbType().equals("postgresql")) {
			sqlQuery = parser.postgresQuery();
		} else if (rqlCoreConf.getRqlDbType().equals("mysql")) {
			sqlQuery = parser.mysqlQuery();
		}
		log("SQL query:\n" + sqlQuery);

		log("initializing oracle connection");
		if (rqlCoreConf.getRqlDbType().equals("oracle")) {
			db = new OracleDB();
		} else if (rqlCoreConf.getRqlDbType().equals("postgresql")) {
			db = new PostgresqlDB();
		} else if (rqlCoreConf.getRqlDbType().equals("mysql")) {
			db = new MysqlDB();
		}
		db.open(rqlCoreConf.getRqlDbHost(), rqlCoreConf.getRqlDbPort(), rqlCoreConf.getRqlDbName(),
				rqlCoreConf.getRqlDbAdminLogin(), rqlCoreConf.getRqlDbAdminPwd());

		System.out.println("\nconnexion etablie \n");

		log("oracle query");
		ResultSet results = db.executeQuery(sqlQuery);

		log("printing results");
		resultsToFile(results, parser.getAttributeList().size());
		results.close();
		db.close();

		log("generating rules");
		int tailleMax = parser.getAttributeList().size();
		Dfg dfg = new Dfg(agFile, agFile + "_rules.txt", 0, 0, tailleMax, shdPath);
		/*
		 * Dfg dfg = new Dfg(agFile + "_rules.txt", tailleMax,
		 * parser.getAttributeList().size()); // set agree set while (results.next()) {
		 * int card = results.getInt(1); String ag = results.getString(2); if (ag !=
		 * null && !ag.equals("")) { String[] elems = ag.split(" "); int[] agr = new
		 * int[elems.length]; for (int i = 0; i < elems.length; i++) { agr[i] =
		 * Integer.parseInt(elems[i]); } dfg.init(card, agr); } } results.close();
		 * db.close(); done
		 */
		try {
			dfg.execute();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(-1);
		}

		log("translating rules");
		List<String> ruleResults = new ArrayList<String>();
		int[] counts = new int[2];
		outStream = new BufferedOutputStream(new FileOutputStream(outFilename), 1024);
		RulesParser.translate(agFile + "_rules.txt", outStream, parser.getAttributeList(), ruleResults, 100000, counts);
		log("RQL query computed");
		return ruleResults;
	}

	private void log(String log) {
		if (output != null) {
			output.println((System.currentTimeMillis() - startTime) + "\t" + log);
		}
	}

	/**
	 * Writes the agree set (results of the SQL query) to the file tmpAgFile
	 * specified in the constructor.
	 * 
	 * @param result  the result of the SQL query
	 * @param attSize the number of attributes used in rules
	 * 
	 * @throws SQLException SQL-related error
	 * @throws IOException  IO-related error
	 */
	private void resultsToFile(ResultSet result, int attSize) throws SQLException, IOException {
		StringBuffer buf = new StringBuffer();

		/* cardinality of the relation: sum of count */
		int cardinality = 0;
		while (result.next()) {
			cardinality += result.getInt(1);
			buf.append(result.getString(1));
			String ag = result.getString(2);
			if (ag != null && !ag.equals("")) {
				buf.append("  " + ag.trim());
			}
			buf.append("\n");
		}

		BufferedWriter out = new BufferedWriter(new FileWriter(agFile));

		out.write(Integer.toString(attSize) + "\n");
		for (int i = 0; i < attSize; i++) {
			if (i > 0) {
				out.write(" ");
			}
			out.write(Integer.toString(i));
		}
		out.write("\n" + Integer.toString(attSize) + " " + Integer.toString(cardinality) + "\n");
		out.write(buf.toString());

		out.flush();
		out.close();
	}

	public void resultsToFile2(List<BaseLine> result, int attSize) throws SQLException, IOException {
		StringBuffer buf = new StringBuffer();

		/* cardinality of the relation: sum of count */
		int cardinality = 0;
		ListIterator<BaseLine> it = result.listIterator();
		while (it.hasNext()) {
			BaseLine ligne = it.next();
			cardinality += Integer.parseInt(ligne.getCount());
			buf.append(ligne.getCount());
			if (ligne.getAg() != null && !ligne.getAg().equals("")) {
				buf.append("  " + ligne.getAg().trim());
			}
			buf.append("\n");
		}
		System.out.println(agFile);
		BufferedWriter out = new BufferedWriter(new FileWriter(agFile));

		out.write(Integer.toString(attSize) + "\n");
		for (int i = 0; i < attSize; i++) {
			if (i > 0) {
				out.write(" ");
			}
			out.write(Integer.toString(i));
		}
		out.write("\n" + Integer.toString(attSize) + " " + Integer.toString(cardinality) + "\n");
		out.write(buf.toString());

		out.flush();
		out.close();
	}

	/**
	 * Updates the temporary file used to store the agree set.
	 * 
	 * @param tmpAgFile the URL of the temporary file
	 */
	public void setTemporaryFile(String tmpAgFile) {
		agFile = tmpAgFile;
	}

	public void executeDFG(String fileIn, String fileOut, int tailleMax, double support, double confidence,
			String m_execpath) {
		Dfg dfg = new Dfg(fileIn, fileOut, support, confidence, tailleMax, m_execpath);
		try {
			dfg.execute();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(-1);
		}
	}

	public RQLResults translate(String ruleFile, String outFile, List<String> parseAttributeList)
			throws ParseException, IOException {
		List<String> listrqlExact = new ArrayList<String>();
		List<Rule> ExactRule = new ArrayList<Rule>();
		List<String> leftAtts;
		String[] sides;
		String[] rightSides;
		Rule rule = new Rule();
		int[] counts = new int[2];
		OutputStream outStream = null;
		outStream = new BufferedOutputStream(new FileOutputStream(ruleFile), 1024);
		RulesParser.translate(outFile, outStream, parseAttributeList, listrqlExact, 100000, counts);
		DecimalFormat df = new DecimalFormat();
		df.setMaximumFractionDigits(3); // arrondi Ã  2 chiffres apres la virgules
		for (int i = 0; i < listrqlExact.size(); i++) {
			rule = new Rule();
			sides = listrqlExact.get(i).split("=>");
			rightSides = sides[1].split("\\s");
			rule.setRightAttributes(rightSides[1]);
			rule.setSupport(Double.valueOf(
					df.format(Double.valueOf(rightSides[5]) / Double.valueOf(rightSides[2])).replace(',', '.')));
			rule.setConfidence(Double.valueOf(
					df.format(Double.valueOf(rightSides[5]) / Double.valueOf(rightSides[3])).replace(',', '.')));
			rule.setLift(Double.valueOf(df
					.format(Double.valueOf(
							rule.getConfidence() / (Double.valueOf(rightSides[4]) / Double.valueOf(rightSides[2]))))
					.replace(',', '.')));
			leftAtts = new ArrayList<String>();
			for (String w : sides[0].split("\\s")) {
				leftAtts.add(w);
			}
			rule.setLeftAttributes(leftAtts);
			ExactRule.add(rule);
		}
		return new RQLResults(ExactRule);
	}

	/**
	 * Sets the output to trace the RQL query, the SQL query and execution times.
	 * 
	 * @param log the URL of the output file, or null to disable
	 * 
	 * @throws IOException IO-related error
	 */
	public void setOutput(String log) throws IOException {
		if (output != null) {
			output.flush();
			output.close();
		}
		output = new PrintStream(log);
	}

	/**
	 * Sets the output to trace the RQL query, the SQL query and execution times.
	 * 
	 * @param log the output stream, or null to disable
	 */
	public void setOutput(PrintStream log) {
		if (output != null) {
			output.flush();
			output.close();
		}
		output = log;
	}

	/**
	 * Closes the connection to the DBMS and file handlers.
	 */
	public void close() throws IOException {
		if (output != null) {
			output.flush();
			output.close();
			output = null;
		}
		db.close();
	}
}
